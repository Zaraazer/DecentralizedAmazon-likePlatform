const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("DecentralizedAmazonPlatform", function () {
  let decentralizedAmazon;
  let owner;
  let seller;
  let buyer;
  let addrs;

  const productPrice = ethers.utils.parseEther("0.1");
  const productQuantity = 10;

  beforeEach(async function () {
    // Get signers
    [owner, seller, buyer, ...addrs] = await ethers.getSigners();

    // Deploy contract
    const DecentralizedAmazonPlatform = await ethers.getContractFactory("DecentralizedAmazonPlatform");
    decentralizedAmazon = await DecentralizedAmazonPlatform.deploy();
    await decentralizedAmazon.deployed();
  });

  describe("Deployment", function () {
    it("Should set the correct owner", async function () {
      expect(await decentralizedAmazon.owner()).to.equal(owner.address);
    });

    it("Should initialize counters to zero", async function () {
      expect(await decentralizedAmazon.productCounter()).to.equal(0);
      expect(await decentralizedAmazon.orderCounter()).to.equal(0);
    });
  });

  describe("Product Listing", function () {
    it("Should list a product successfully", async function () {
      await decentralizedAmazon.connect(seller).listProduct(
        "Test Product",
        "This is a test product",
        productPrice,
        productQuantity,
        "QmTestHash"
      );

      expect(await decentralizedAmazon.productCounter()).to.equal(1);
      
      const product = await decentralizedAmazon.products(1);
      expect(product.name).to.equal("Test Product");
      expect(product.price).to.equal(productPrice);
      expect(product.quantity).to.equal(productQuantity);
      expect(product.seller).to.equal(seller.address);
      expect(product.isActive).to.equal(true);
    });

    it("Should emit ProductListed event", async function () {
      await expect(
        decentralizedAmazon.connect(seller).listProduct(
          "Test Product",
          "This is a test product",
          productPrice,
          productQuantity,
          "QmTestHash"
        )
      ).to.emit(decentralizedAmazon, "ProductListed")
       .withArgs(1, "Test Product", productPrice, seller.address);
    });

    it("Should fail with empty product name", async function () {
      await expect(
        decentralizedAmazon.connect(seller).listProduct(
          "",
          "This is a test product",
          productPrice,
          productQuantity,
          "QmTestHash"
        )
      ).to.be.revertedWith("Product name cannot be empty");
    });

    it("Should fail with zero price", async function () {
      await expect(
        decentralizedAmazon.connect(seller).listProduct(
          "Test Product",
          "This is a test product",
          0,
          productQuantity,
          "QmTestHash"
        )
      ).to.be.revertedWith("Price must be greater than 0");
    });

    it("Should fail with zero quantity", async function () {
      await expect(
        decentralizedAmazon.connect(seller).listProduct(
          "Test Product",
          "This is a test product",
          productPrice,
          0,
          "QmTestHash"
        )
      ).to.be.revertedWith("Quantity must be greater than 0");
    });
  });

  describe("Product Purchase", function () {
    beforeEach(async function () {
      // List a product first
      await decentralizedAmazon.connect(seller).listProduct(
        "Test Product",
        "This is a test product",
        productPrice,
        productQuantity,
        "QmTestHash"
      );
    });

    it("Should purchase product successfully", async function () {
      const purchaseQuantity = 2;
      const totalPrice = productPrice.mul(purchaseQuantity);

      await decentralizedAmazon.connect(buyer).purchaseProduct(1, purchaseQuantity, {
        value: totalPrice
      });

      expect(await decentralizedAmazon.orderCounter()).to.equal(1);
      
      const order = await decentralizedAmazon.orders(1);
      expect(order.productId).to.equal(1);
      expect(order.quantity).to.equal(purchaseQuantity);
      expect(order.totalPrice).to.equal(totalPrice);
      expect(order.buyer).to.equal(buyer.address);
      expect(order.seller).to.equal(seller.address);
      expect(order.status).to.equal(0); // Pending

      // Check product quantity updated
      const product = await decentralizedAmazon.products(1);
      expect(product.quantity).to.equal(productQuantity - purchaseQuantity);
    });

    it("Should emit ProductPurchased event", async function () {
      const purchaseQuantity = 2;
      const totalPrice = productPrice.mul(purchaseQuantity);

      await expect(
        decentralizedAmazon.connect(buyer).purchaseProduct(1, purchaseQuantity, {
          value: totalPrice
        })
      ).to.emit(decentralizedAmazon, "ProductPurchased")
       .withArgs(1, 1, buyer.address, purchaseQuantity);
    });

    it("Should handle platform fee correctly", async function () {
      const purchaseQuantity = 1;
      const totalPrice = productPrice.mul(purchaseQuantity);
      const platformFee = totalPrice.mul(2).div(100); // 2%
      const sellerAmount = totalPrice.sub(platformFee);

      await decentralizedAmazon.connect(buyer).purchaseProduct(1, purchaseQuantity, {
        value: totalPrice
      });

      expect(await decentralizedAmazon.getSellerBalance(seller.address)).to.equal(sellerAmount);
      expect(await decentralizedAmazon.getSellerBalance(owner.address)).to.equal(platformFee);
    });

    it("Should refund excess payment", async function () {
      const purchaseQuantity = 1;
      const totalPrice = productPrice.mul(purchaseQuantity);
      const excessAmount = ethers.utils.parseEther("0.05");
      const paymentAmount = totalPrice.add(excessAmount);

      const initialBalance = await buyer.getBalance();
      
      const tx = await decentralizedAmazon.connect(buyer).purchaseProduct(1, purchaseQuantity, {
        value: paymentAmount
      });
      
      const receipt = await tx.wait();
      const gasUsed = receipt.gasUsed.mul(receipt.effectiveGasPrice);
      const finalBalance = await buyer.getBalance();

      // Balance should decrease by totalPrice + gas, not the full payment
      const expectedBalance = initialBalance.sub(totalPrice).sub(gasUsed);
      expect(finalBalance).to.be.closeTo(expectedBalance, ethers.utils.parseEther("0.001"));
    });

    it("Should fail with insufficient payment", async function () {
      const purchaseQuantity = 2;
      const totalPrice = productPrice.mul(purchaseQuantity);
      const insufficientPayment = totalPrice.sub(ethers.utils.parseEther("0.01"));

      await expect(
        decentralizedAmazon.connect(buyer).purchaseProduct(1, purchaseQuantity, {
          value: insufficientPayment
        })
      ).to.be.revertedWith("Insufficient payment");
    });

    it("Should fail with insufficient product quantity", async function () {
      const purchaseQuantity = productQuantity + 1;
      const totalPrice = productPrice.mul(purchaseQuantity);

      await expect(
        decentralizedAmazon.connect(buyer).purchaseProduct(1, purchaseQuantity, {
          value: totalPrice
        })
      ).to.be.revertedWith("Insufficient product quantity");
    });

    it("Should deactivate product when quantity reaches zero", async function () {
      const totalPrice = productPrice.mul(productQuantity);

      await decentralizedAmazon.connect(buyer).purchaseProduct(1, productQuantity, {
        value: totalPrice
      });

      const product = await decentralizedAmazon.products(1);
      expect(product.quantity).to.equal(0);
      expect(product.isActive).to.equal(false);
    });
  });

  describe("Order Status Management", function () {
    beforeEach(async function () {
      // List and purchase a product
      await decentralizedAmazon.connect(seller).listProduct(
        "Test Product",
        "This is a test product",
        productPrice,
        productQuantity,
        "QmTestHash"
      );

      await decentralizedAmazon.connect(buyer).purchaseProduct(1, 2, {
        value: productPrice.mul(2)
      });
    });

    it("Should allow seller to mark order as shipped", async function () {
      await decentralizedAmazon.connect(seller).updateOrderStatus(1, 1); // Shipped

      const order = await decentralizedAmazon.orders(1);
      expect(order.status).to.equal(1); // Shipped
    });

    it("Should allow buyer to mark order as delivered", async function () {
      // First mark as shipped
      await decentralizedAmazon.connect(seller).updateOrderStatus(1, 1); // Shipped
      
      // Then mark as delivered
      await decentralizedAmazon.connect(buyer).updateOrderStatus(1, 2); // Delivered

      const order = await decentralizedAmazon.orders(1);
      expect(order.status).to.equal(2); // Delivered
    });

    it("Should emit OrderStatusUpdated event", async function () {
      await expect(
        decentralizedAmazon.connect(seller).updateOrderStatus(1, 1)
      ).to.emit(decentralizedAmazon, "OrderStatusUpdated")
       .withArgs(1, 1);
    });

    it("Should allow order cancellation and refund", async function () {
      const initialBalance = await buyer.getBalance();
      const orderTotalPrice = productPrice.mul(2);

      const tx = await decentralizedAmazon.connect(buyer).updateOrderStatus(1, 3); // Cancelled
      const receipt = await tx.wait();
      const gasUsed = receipt.gasUsed.mul(receipt.effectiveGasPrice);

      const finalBalance = await buyer.getBalance();
      const expectedBalance = initialBalance.add(orderTotalPrice).sub(gasUsed);

      expect(finalBalance).to.be.closeTo(expectedBalance, ethers.utils.parseEther("0.001"));

      // Check product quantity restored
      const product = await decentralizedAmazon.products(1);
      expect(product.quantity).to.equal(productQuantity);
      expect(product.isActive).to.equal(true);
    });

    it("Should not allow buyer to mark as shipped", async function () {
      await expect(
        decentralizedAmazon.connect(buyer).updateOrderStatus(1, 1)
      ).to.be.revertedWith("Only seller can mark as shipped");
    });

    it("Should not allow seller to mark as delivered", async function () {
      await decentralizedAmazon.connect(seller).updateOrderStatus(1, 1); // Shipped first
      
      await expect(
        decentralizedAmazon.connect(seller).updateOrderStatus(1, 2)
      ).to.be.revertedWith("Only buyer can mark as delivered");
    });
  });

  describe("Fund Withdrawal", function () {
    beforeEach(async function () {
      // List and purchase a product to generate seller balance
      await decentralizedAmazon.connect(seller).listProduct(
        "Test Product",
        "This is a test product",
        productPrice,
        productQuantity,
        "QmTestHash"
      );

      await decentralizedAmazon.connect(buyer).purchaseProduct(1, 2, {
        value: productPrice.mul(2)
      });
    });

    it("Should allow seller to withdraw funds", async function () {
      const initialBalance = await seller.getBalance();
      const sellerBalance = await decentralizedAmazon.getSellerBalance(seller.address);

      const tx = await decentralizedAmazon.connect(seller).withdrawFunds();
      const receipt = await tx.wait();
      const gasUsed = receipt.gasUsed.mul(receipt.effectiveGasPrice);

      const finalBalance = await seller.getBalance();
      const expectedBalance = initialBalance.add(sellerBalance).sub(gasUsed);

      expect(finalBalance).to.be.closeTo(expectedBalance, ethers.utils.parseEther("0.001"));
      expect(await decentralizedAmazon.getSellerBalance(seller.address)).to.equal(0);
    });

    it("Should emit FundsWithdrawn event", async function () {
      const sellerBalance = await decentralizedAmazon.getSellerBalance(seller.address);

      await expect(
        decentralizedAmazon.connect(seller).withdrawFunds()
      ).to.emit(decentralizedAmazon, "FundsWithdrawn")
       .withArgs(seller.address, sellerBalance);
    });

    it("Should not allow withdrawal with zero balance", async function () {
      await decentralizedAmazon.connect(seller).withdrawFunds(); // First withdrawal

      await expect(
        decentralizedAmazon.connect(seller).withdrawFunds()
      ).to.be.revertedWith("No funds to withdraw");
    });
  });

  describe("View Functions", function () {
    beforeEach(async function () {
      // Setup test data
      await decentralizedAmazon.connect(seller).listProduct(
        "Active Product",
        "This is an active product",
        productPrice,
        productQuantity,
        "QmActiveHash"
      );

      await decentralizedAmazon.connect(seller).listProduct(
        "Inactive Product",
        "This product will be inactive",
        productPrice,
        1,
        "QmInactiveHash"
      );

      // Purchase all of second product to make it inactive
      await decentralizedAmazon.connect(buyer).purchaseProduct(2, 1, {
        value: productPrice
      });
    });

    it("Should return only active products", async function () {
      const activeProducts = await decentralizedAmazon.getActiveProducts();
      expect(activeProducts.length).to.equal(1);
      expect(activeProducts[0].name).to.equal("Active Product");
      expect(activeProducts[0].isActive).to.equal(true);
    });

    it("Should return seller products", async function () {
      const sellerProducts = await decentralizedAmazon.getSellerProducts(seller.address);
      expect(sellerProducts.length).to.equal(2);
      expect(sellerProducts[0]).to.equal(1);
      expect(sellerProducts[1]).to.equal(2);
    });

    it("Should return buyer orders", async function () {
      const buyerOrders = await decentralizedAmazon.getBuyerOrders(buyer.address);
      expect(buyerOrders.length).to.equal(1);
      expect(buyerOrders[0]).to.equal(1);
    });

    it("Should return product details", async function () {
      const product = await decentralizedAmazon.getProductDetails(1);
      expect(product.name).to.equal("Active Product");
      expect(product.seller).to.equal(seller.address);
      expect(product.isActive).to.equal(true);
    });

    it("Should return order details", async function () {
      const order = await decentralizedAmazon.getOrderDetails(1);
      expect(order.productId).to.equal(2);
      expect(order.buyer).to.equal(buyer.address);
      expect(order.seller).to.equal(seller.address);
    });
  });
});
